import { errorHandler } from '../../../src/middlewares/errorHandler';
import { AppError } from '../../../src/utils/appError';

// Mock the logger
jest.mock('../../../src/utils/logger', () => ({
  logger: {
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn(),
  },
}));

import { logger } from '../../../src/utils/logger';

describe('Error Handler Middleware', () => {
  let mockReq: any;
  let mockRes: any;
  let mockNext: any;

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();

    mockReq = {
      originalUrl: '/api/test',
      method: 'GET',
      ip: '127.0.0.1',
      get: jest.fn().mockReturnValue('Mozilla/5.0'),
      user: { id: 'user123' },
      id: 'req-123',
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    mockNext = jest.fn();

    // Reset environment
    process.env.NODE_ENV = 'test';
  });

  describe('when handling AppError', () => {
    it('should handle 400 Bad Request error', () => {
      const appError = new AppError('Validation failed', 400);
      appError.stack = 'Error stack trace';

      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalledWith(
        {
          error: 'Validation failed',
          stack: 'Error stack trace',
          statusCode: 400,
          path: '/api/test',
          method: 'GET',
          ip: '127.0.0.1',
          userAgent: 'Mozilla/5.0',
          userId: 'user123',
          requestId: 'req-123',
        },
        'Application error: Validation failed'
      );

      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.json).toHaveBeenCalledWith({
        status: 400,
        error: {
          message: 'Validation failed',
          statusCode: 400,
          isOperational: true,
        },
        success: false,
        stack: 'Error stack trace',
      });
    });

    it('should handle 401 Unauthorized error', () => {
      const appError = new AppError('Unauthorized', 401);

      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalled();
      expect(mockRes.status).toHaveBeenCalledWith(401);
      expect(mockRes.json).toHaveBeenCalledWith({
        status: 401,
        error: {
          message: 'Unauthorized',
          statusCode: 401,
          isOperational: true,
        },
        success: false,
        stack: expect.any(String),
      });
    });

    it('should handle 500 Internal Server Error', () => {
      const appError = new AppError('Database connection failed', 500);
      appError.stack = 'Database error stack';

      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.error).toHaveBeenCalledWith(
        {
          error: 'Database connection failed',
          stack: 'Database error stack',
          statusCode: 500,
          path: '/api/test',
          method: 'GET',
          ip: '127.0.0.1',
          userAgent: 'Mozilla/5.0',
          userId: 'user123',
          requestId: 'req-123',
        },
        'Application error: Database connection failed'
      );

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.json).toHaveBeenCalledWith({
        status: 500,
        error: {
          message: 'Database connection failed',
          statusCode: 500,
          isOperational: true,
        },
        success: false,
        stack: 'Database error stack',
      });
    });

    it('should handle AppError without statusCode', () => {
      const appError = new AppError('Unknown error', 500);
      // Override statusCode to undefined for testing
      (appError as any).statusCode = undefined;

      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.json).toHaveBeenCalledWith({
        status: 500,
        error: {
          message: 'Unknown error',
          statusCode: undefined,
          isOperational: true,
        },
        success: false,
        stack: expect.any(String),
      });
    });
  });

  describe('when handling generic errors', () => {
    it('should convert generic Error to AppError', () => {
      const genericError = new Error('Something went wrong');
      genericError.stack = 'Generic error stack';

      errorHandler(genericError, mockReq, mockRes, mockNext);

      expect(logger.error).toHaveBeenCalledWith(
        {
          error: 'Internal Server Error: Something went wrong',
          stack: expect.any(String), // Stack trace is generated by AppError
          statusCode: 500,
          path: '/api/test',
          method: 'GET',
          ip: '127.0.0.1',
          userAgent: 'Mozilla/5.0',
          userId: 'user123',
          requestId: 'req-123',
        },
        'Application error: Internal Server Error: Something went wrong'
      );

      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.json).toHaveBeenCalledWith({
        status: 500,
        error: {
          message: 'Internal Server Error: Something went wrong',
          statusCode: 500,
          isOperational: true,
        },
        success: false,
        stack: expect.any(String),
      });
    });

    it('should handle error without message', () => {
      const errorWithoutMessage = new Error();
      errorWithoutMessage.message = '';

      errorHandler(errorWithoutMessage, mockReq, mockRes, mockNext);

      expect(logger.error).toHaveBeenCalledWith(
        expect.objectContaining({
          error: 'Internal Server Error: ',
        }),
        'Application error: Internal Server Error: '
      );
    });

    it('should handle non-Error objects', () => {
      const nonErrorObject = { message: 'Not an Error instance' };

      errorHandler(nonErrorObject, mockReq, mockRes, mockNext);

      expect(logger.error).toHaveBeenCalledWith(
        expect.objectContaining({
          error: 'Internal Server Error: Not an Error instance',
        }),
        'Application error: Internal Server Error: Not an Error instance'
      );
    });
  });

  describe('environment-specific behavior', () => {
    it('should hide stack trace in production', () => {
      process.env.NODE_ENV = 'production';
      const appError = new AppError('Test error', 400);
      appError.stack = 'Error stack trace';

      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(mockRes.json).toHaveBeenCalledWith({
        status: 400,
        error: appError,
        success: false,
        stack: null,
      });
    });

    it('should show stack trace in development', () => {
      process.env.NODE_ENV = 'development';
      const appError = new AppError('Test error', 400);
      appError.stack = 'Error stack trace';

      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(mockRes.json).toHaveBeenCalledWith({
        status: 400,
        error: {
          message: 'Test error',
          statusCode: 400,
          isOperational: true,
        },
        success: false,
        stack: 'Error stack trace',
      });
    });

    it('should show stack trace in test environment', () => {
      process.env.NODE_ENV = 'test';
      const appError = new AppError('Test error', 400);
      appError.stack = 'Error stack trace';

      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(mockRes.json).toHaveBeenCalledWith({
        status: 400,
        error: {
          message: 'Test error',
          statusCode: 400,
          isOperational: true,
        },
        success: false,
        stack: 'Error stack trace',
      });
    });
  });

  describe('logging levels', () => {
    it('should use error level for 5xx status codes', () => {
      const appError = new AppError('Server error', 500);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.error).toHaveBeenCalled();
      expect(logger.warn).not.toHaveBeenCalled();
    });

    it('should use warn level for 4xx status codes', () => {
      const appError = new AppError('Client error', 400);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalled();
      expect(logger.error).not.toHaveBeenCalled();
    });

    it('should use warn level for 3xx status codes', () => {
      const appError = new AppError('Redirect error', 300);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalled();
      expect(logger.error).not.toHaveBeenCalled();
    });

    it('should use warn level for 2xx status codes', () => {
      const appError = new AppError('Success error', 200);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalled();
      expect(logger.error).not.toHaveBeenCalled();
    });
  });

  describe('request context extraction', () => {
    it('should handle missing request properties', () => {
      const minimalReq = {
        originalUrl: '/api/test',
        method: 'GET',
        ip: undefined,
        get: jest.fn().mockReturnValue(undefined),
        user: undefined,
        id: undefined,
      } as any;

      const appError = new AppError('Test error', 400);
      errorHandler(appError, minimalReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalledWith(
        expect.objectContaining({
          ip: undefined,
          userAgent: undefined,
          userId: undefined,
          requestId: undefined,
        }),
        'Application error: Test error'
      );
    });

    it('should handle missing user object', () => {
      mockReq.user = undefined;

      const appError = new AppError('Test error', 400);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalledWith(
        expect.objectContaining({
          userId: undefined,
        }),
        'Application error: Test error'
      );
    });

    it('should handle user object without id', () => {
      mockReq.user = { name: 'John' };

      const appError = new AppError('Test error', 400);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(logger.warn).toHaveBeenCalledWith(
        expect.objectContaining({
          userId: undefined,
        }),
        'Application error: Test error'
      );
    });
  });

  describe('error response format', () => {
    it('should always include success: false', () => {
      const appError = new AppError('Test error', 400);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(mockRes.json).toHaveBeenCalledWith(
        expect.objectContaining({
          success: false,
        })
      );
    });

    it('should always include status code', () => {
      const appError = new AppError('Test error', 422);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(mockRes.json).toHaveBeenCalledWith(
        expect.objectContaining({
          status: 422,
        })
      );
    });

    it('should always call res.status() before res.json()', () => {
      const appError = new AppError('Test error', 400);
      errorHandler(appError, mockReq, mockRes, mockNext);

      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.json).toHaveBeenCalled();

      // Verify status was called before json
      const statusCallOrder = mockRes.status.mock.invocationCallOrder[0];
      const jsonCallOrder = mockRes.json.mock.invocationCallOrder[0];
      expect(statusCallOrder).toBeLessThan(jsonCallOrder);
    });
  });
});
